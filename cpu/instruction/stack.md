# スタック操作

<pre>
Note: サイクル数は<a href="../cycle.md#マシンサイクル">マシンサイクル</a>単位です。
</pre>

## ADD HL,SP

<pre>
SPレジスタの値とHLレジスタの値を足す

サイクル: 2
バイト長: 1
フラグ:
    Z: 不変
    N: 0
    H: bit11からオーバーフローした場合にセット
    C: bit15からオーバーフローした場合にセット
</pre>

## ADD SP,e8

<pre>
<a href="./README.md#記号の意味">e8(8bit整数)</a>とSPレジスタの値を足す

サイクル: 4
バイト長: 2
フラグ:
    Z: 0
    N: 0
    H: bit3からオーバーフローした場合にセット
    C: bit7からオーバーフローした場合にセット
</pre>

## INC SP

<pre>
SPレジスタの値をインクリメント(+1)する  
処理結果はSPレジスタに格納される

サイクル: 2
バイト長: 1
フラグ: 不変
</pre>

## DEC SP

<pre>
SPレジスタの値をデクリメント(-1)する  
処理結果はSPレジスタに格納される

サイクル: 2
バイト長: 1
フラグ: 不変
</pre>

## LD SP,n16

<pre>
n16をSPレジスタに格納

サイクル: 3
バイト長: 3
フラグ: 不変
</pre>

## LD [n16],SP

<pre>
SPの下位バイト(bit0-7)をアドレスn16のメモリに、上位バイト(bit8-15)をアドレス(n16+1)のメモリに格納
[n16] = SP & 0xFF, [n16+1] = (SP >> 8)

サイクル: 5
バイト長: 3
フラグ: 不変
</pre>

## LD HL,SP+e8

<pre>
<a href="./README.md#記号の意味">e8(8bit整数)</a>とSPレジスタの値を足したものをHLレジスタに格納
SPレジスタは不変

サイクル: 3
バイト長: 2
フラグ:
    Z: 0
    N: 0
    H: bit3からオーバーフローした場合にセット
    C: bit7からオーバーフローした場合にセット
</pre>

## LD SP,HL

<pre>
HLレジスタの値をSPレジスタに格納

サイクル: 2
バイト長: 1
フラグ: 不変
</pre>

## PUSH AF

<pre>
AFレジスタの値をスタックにプッシュする
内容的には、以下のコードを実行したのと同じ

    dec sp
    ld [sp], a
    dec sp
    ld [sp], flag_Z << 7 | flag_N << 6 | flag_H << 5 | flag_C << 4

サイクル: 4
バイト長: 1
フラグ: 不変
</pre>

## PUSH r16

<pre>
r16の値をスタックにプッシュする
内容的には、以下のコードを実行したのと同じ

    dec sp
    ld [sp], HIGH(r16) ; B, D or H
    dec sp
    ld [sp], LOW(r16) ; C, E or L

サイクル: 4
バイト長: 1
フラグ: 不変
</pre>

## POP AF

<pre>
スタックの先頭から16bitの値を取り出して、AFレジスタに格納する
Fレジスタに最初の1バイト[SP]が、Aレジスタに次のバイト[SP+1]が格納される
内容的には、以下のコードを実行したのと同じ

    ld f, [sp] ; フラグに影響を与える
    inc sp
    ld a, [sp]
    inc sp

サイクル: 3
バイト長: 1
フラグ:
    Z: 取り出した16bit値の7bit目
    N: 取り出した16bit値の6bit目
    H: 取り出した16bit値の5bit目
    C: 取り出した16bit値の4bit目
</pre>

## POP r16

<pre>
スタックの先頭から16bitの値を取り出して、r16に格納する
下位レジスタに最初の1バイト[SP]が、上位レジスタに次のバイト[SP+1]が格納される
内容的には、以下のコードを実行したのと同じ

    ld LOW(r16), [sp] ; C, E or L
    inc sp
    ld HIGH(r16), [sp] ; B, D or H
    inc sp

サイクル: 3
バイト長: 1
フラグ: 不変
</pre>

